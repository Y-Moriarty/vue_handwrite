<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vue</title>
  </head>
  <body>
    <div id="app" style="color: red; font-size: 20px">
      hello{{msg}}
      <h1>张三</h1>
      <h2>{{a.b}}</h2>
      <h3>{{arr}}</h3>
      <h4>{{b}}</h4>
    </div>
    <script src="dist/vue.js"></script>
    <script>
      // 全局的生命周期函数先于自定义的生命周期函数执行
      // Vue.Mixin({
      //   created: function a() {
      //     console.log('a')
      //   }
      // })
      // Vue.Mixin({
      //   created: function b() {
      //     console.log('b')
      //   }
      // })

      // umd Vue
      // console.log(Vue)
      // 响应式 vue2
      // new Vue 时对传入对象的所有内容进行初始化
      let vm = new Vue({
        el: '#app',
        data() {
          // console.log(this) // 如果 initState 不使用 call() -> window
          return {
            msg: 'hello2',
            a: { b: 20 },
            list: [1, 2, 3],
            arr: [
              {
                a: 1
              }
            ],
            b: 200
          }
        },
        // data: {
        //   msg: 'hello'
        // },
        props: {},
        watch: {
          // a(newVal, oldVal) {
          //   console.log('watch')
          // },
          'a.b'(newVal, oldVal) {
            console.log('watch a.b')
          },
          b: {
            handler() {
              console.log('handler')
            },
            immediate: true
          }
        },

        // ...
        created() {
          console.log('created')
        },
        updated() {
          console.log('updated')
        }
      })
      // .$mount("#app") // 作用和 el 一样

      // console.log("vm: ", vm);
      // console.log("vm set: ", (vm._data.msg = 100));
      // console.log("vm: ", vm._data.msg);
      // console.log('vm._data: ', vm._data)
      // console.log("vm list: ", vm._data.list.push(4, 5));
      // console.log("vm push: ", vm._data.arr.push({ a: 4, b: 5 }));
      // console.log("vm arr: ", vm.arr);
      // console.log("vm.msg: ", (vm.msg = 100));

      // setTimeout(() => {
      //   vm.msg = 'world'
      //   // 手动触发更新，重新走一遍模板编译
      //   vm._update(vm._render())
      // }, 1000)
      // * 一、实现自动更新
      // 1. 数据变化，自动更新视图 vm._update(vm._render())
      // 2. vue 的更新策略：以组件为单位，给每一个组件添加一个 watcher，当属性变化时，调用 watcher
      console.log(vm)
      setTimeout(() => {
        // 自动更新 - 将 vm._update(vm._render()) 封装成函数，在数据更新时调用
        // 此时每一次更新都会调用 vm._update(vm._render()) - 性能开销大
        // 解决：使用队列(nextTick) - 批量处理 - 多次数据更新，只调用一次 vm._update(vm._render())
        //  异步处理 - 数据更新后，不会立即执行
        //  - watcher.js 的 update()
        vm.msg = 'world'
        vm.arr.push({ a: 4, b: 5 })
        // vm.$nextTick(() => {
        //   // 数据更新后，获取到最新的 dom
        //   console.log('🚀 ~ vm.$nextTick ~ vm.$el.innerHTML:', vm.$el.innerHTML)
        // })
        vm.b = 300
        vm.a.b = 500
      }, 1000)

      // * 二、实现对象收集依赖
      // dep 和 watcher 关系 - 多对多

      // * 三、数组收集
      // 思路：
      // 1. 给所有对象类型增加一个 dep
      // 2. 获取数组的值，会调用 get 方法时让当前数组记住这个 watcher
      //  2.1 需要获取到当前 dep
      //  2.2 面对数组取值的时候，让数组的 dep 记住这个 wathcer
      // 3. 当更新数组的时候，找到这个 watcher 进行更新

      // * 面试题：
      // Vue 初次渲染
      //  初始化数据 =>将模板进行编译 => Vue 模板编译（el 必须要有）=> 得到 render 函数 => 生成虚拟节点 => 转变为真实 DOM => 放到页面上
      // 模板编译的三种方式：render -> template -> el(通过 el 获取元素)
      // 查看官网生命周期图示

      // 手写 vue 的难点
      // 1. 模板编译
      // 2. 数据依赖
      // 3. 生命周期

      // Vue 生命周期的实现原理
      // 1. Vue.Mixin({}) - 混入
      // 2. 生命周期其实是一种基于订阅发布的设计模式，将 new Vue() 传入的对象存入 options

      // watch 实现原理
    </script>
  </body>
</html>
